			动手构建一个编译器！
			Jack W. Crenshaw, Ph.D.
			24 July 1988

			第二部分：表达式解析

版权许可：
Copyright (C) 1988 Jack W. Crenshaw. 保留一切权利。
本文由梓瑶翻译并重写为 Lua 代码

开始

如果你度过了这个系列的简介，你应该已经知道我们的主题了，并且也已经复制
编译过基本框架的代码了。现在你已经做好开始的准备了。

这篇文章的目的是让我们学习如何解析和翻译数学表达式。我们希望得到的输出
是一系列执行对应操作的汇编语句。为了让目的定义得更明确一些，我们把等式
中等号右侧的部分称作表达式，例如

	x = 2 * y + 3 / (4 * z)

开始的时候我会一小步一小步地前进，这样读者中的初学者就不会被绕晕了。有
一些东西早一点学习是有利的，以后这会给我们带来回报。有经验的读者请先忍
受一下，我们很快就会加快节奏的。

单个的数字

为了和整个系列的风格保持一致（还记得 KISS 原则吗？），我们从能想到的绝
对是最简单的情况开始：只包含一个数字的表达式。

在开始写代码之前，先确保你有我上次给出的基础框架的一份拷贝。我们会在别
的实验中再次用到它。然后加上这些代码。

-- 解析并翻译一个数学表达式
local function expression()
	emitLine("movq	$" .. getNum() .. ",	%rax");
end;

然后把 "expression();" 加到主程序中，现在主程序看起来大概是这样：

init();
expression();

现在运行一下这个程序。尝试随便输入一个数字，你应该能得到一行汇编代码作
为输出。再试试输入别的字符，你就能看见解析器正确地报错了。

撒花！你已经写了一个能工作的翻译器了！

嗯，我向你承认这个有点太受限了，但是别这么早就下结论。这个小小的“编译
器”虽然实现的功能非常少，但是却做了和更大型的编译器一样的的事情：它正
确地识别了我们定义的输入“语言”中合法的语句并输出了正确并且可以运行的汇
编代码，用来编译成对象文件格式正合适。一样重要地，它还准确识别出了不合
法的语句，然后给出了一条友好的错误信息。这还不够吗？在扩展编译器的时候
，我们最好永远维护好这两个特性。

这个小程序有一些别的值得一提的特性。首先，你可以看到我们没有把解析和代
码生成分割开... 一旦解析器知道我们要做什么了，它就立刻生成代码。当然，
在真实的编译器中，getChar() 会从磁盘上的文件读取字符，然后把输出写入到
另一个磁盘上的文件中；但是我们做实验的时候这样处理要简单地多。

同时也要注意，为一个表达式生成的代码一定要把计算后的结果存放起来。我选
择存放在 x86-64 处理器的 rax 寄存器中。当然有别的选择，但是这样做有之
道理。

二元表达式

现在我们手里已经有一个编译器了，接下来就扩展一下它吧。我承认只包含一个
字符的“表达式”满足不了我们的长期需要，所以来看看怎么做能扩展它。假设我
们要处理这种形式的表达式：

				1 + 2
	或者			4 - 3
	或者，一般一点讲，	<term> +/- <term>

（这有点像 Backus-Naur 文法（BNF）了）

我们需要一个函数来解析一个项（term）并且把它对应的值存放在什么地方，还
需要另一个来识别 '+' 和 '-' 并且生成对应的代码。不过 expression() 生成
的代码已经把表达式的结果放在 %rax 里面了，term() 把它的结果放在哪呢？
答案是：也放在 %rax 里。我们在获取到第下一项之前，先把第一个项的值找个
地方存起来。

好的，基本上 term() 做的事情就是原来 expression() 所做的。所以我们只需
要把 expression() 重命名成 term()，然后写上这个新的 expression()：

local function expression()
	term();
	emitLine("movq	%rax,	%rdx");
	if look == '+'
	then
		add();
	elseif look == '-'
	then
		substract();
	else
		expect("Addop");
	end
end

然后在 expression() 之前加上这两个函数：

local function add()
	match('+');
	term();
	emitLine("addq	%rdx,	%rax");
end

local function substract()
	match('-');
	term();
	emitLine("addq	%rdx,	%rax");
end

加上之后，现在这些函数应该按照这个顺序排列起来了：

 o term() （原来的 expression()）
 o add()
 o substract()
 o expression()

现在运行一下我们的代码。随便试试你能想到的两个数字，中间加上一个加号或
减号，每次运行你应该都能得到一系列汇编指令输出。再试试在输入里带上点错
误，你的解析器是不是发现了它呢？

现在来看看生成的代码：我们能发现两点问题。首先，我们绝对不会手写出这样
的东西来。代码序列

	movq	$n,	%rax
	movq	%rax,	%rdx

相当低效。如果我们是在手写这些代码，我们大概就直接把数据加载到 rax 中
了。

这里提示我们：我们的解析器生成的代码比人工写出来的要低效地多。必须习惯
这一点，在这整个系列中都是这样。某种程度上说，所有的编译器都是这样。计
算机科学家们花了毕生经历来解决代码优化问题，并且我们确实可以做点什么来
提高输出代码的质量。有些编译器在这方面也做得很不错，但是代价是大幅提高
了代码的复杂度，而且不管怎么说....这场战争我们都是要输的。编译器很可能
永远也打不过一个优秀的汇编程序员。在这篇文章的结尾，我会简要讲解一些优
化的方式，这只不过是为了告诉你我们确实可以不太费力气地改善一点代码的质
量。但是牢记，我们正在学习编译器构建，而不是要生成最简洁的目标代码。对
于现在（实际上在是整个一系列文章中）我们就刻意忽略掉优化，集中精力生成
能工作的代码吧。

但是：我们的代码根本不对！它是错的！尽管看起来一切正常，substraction()
却从 rax （里面有加号右侧的项）中减去了 rdx（里面有等号左侧的项）。这
么做是错误的，最后得到的结果的符号反了。所以现在我们就改变一下结果的符
号来修复 substraction() 吧。这样它就变成


local function substract()
	match('-');
	term();
	emitLine("subq	%rdx,	%rax");
	emitLine("negq	%rax");
end

local function expression()
	term();
	emitLine("movq	%rax,	%rdx");
	if look == '+'
	then
		add();
	elseif look == '-'
	then
		substract();
	else
		expect("Addop");
	end
end

-- 主程序从这里开始

init();
expression();

现在我们的代码效率更低了，但是至少答案是对的！不幸的是，数学表达式的意
义的使得表达式中的项出现的顺序很别扭。但是我不得不重复一下，这就是生活
，你必须习惯。这个问题等到我们研究除法时还会回来咬我们一口。

好的，现在我们有一个认识两个数字的和与差的解析器了，之前我们还只认识一
个数字来着。但是真实世界的表达式可能是其中任何一种形式（还有无数种其他
的形式）。作为尝试，我们回去运行一下我们的程序，仅输入一个 '1'。

它炸了吧？为什么会这样呢？我们刚刚才告诉我们的解析器唯一一种合法的表达
式是包含两个项的那种。我们必须得重写 expression() 来扩宽一下它能处理的
表达式集合。慢慢地，我们的解析器开始和真实的解析器相仿了。

一般的表达式

真实世界中，一个表达式可以包含一个以上用加号或者减号（且统称为 addop）
分隔的项。用 BNF文法可以写成这种形式：

	<expression> ::= <term> [<addop> <term>]*

我们可以在 expression() 加上一个简单的循环来处理表达式的这种定义。

local function expression()
	term();

	while look == '+' or look == '-'
	do
		emitLine("movq	%rax,	%rdx");
		if look == '+'
		then
			add();
		elseif look == '-'
		then
			substract();
		else
			expect("Addop");
		end
	end
end

大功告成！这个版本可以处理包含任意数量项的表达式，并且只多花了我们三行
代码。边读着这系列文章你就会发现这就是自顶向下解析器的特点....只花几行
代码就能扩展一下我们的语言，这就使得我们逐步扩展编译器的方案有了实施的
可能性。也要注意，expression() 与 BNF 文法的定义对应得非常完美，这也是
自顶向下解析器的特点。熟练了之后，你会发现自己把 BNF 定义改写成代码的
速度就和你敲键盘的速度一样快！

好，现在运行一下我们新版本的编译器试试。和原来一样验证一下我们的“编译
器”能处理所有合法的表达式，并且会对不合法的表达式给出一条友好的错误信
息。不错吧？你可能发现我们的测试版本里错误信息埋在一堆已经生成的代码里
。但是，这就是在这一系列文章中我们把屏幕当作“输出文件”的后果。产品编译
器中代码中输出应该是分开的，一个是文件，一个是屏幕。

使用栈

现在我得打破一下我们不会在绝对必要指出我们生成代码中问题的时候才引入复
杂东西的规则了。一切看起来是那么美好，解析器用 rax 作为“主”寄存器，把
rdx 当作储存部分和的地方。现在看起来一切都那么完美，因为我们现在只处理
加号和减号，一旦我们读入一个新的项就可以立马把它加上。但是一般情况下，
我们不能总是这么处理。考虑一下这个表达式作为例子：

		1 + (2 - ( 3 + (4 - 5)))

如果我们把 '1' 存在 rax 里，'2' 放哪？既然一个一般的表达式要多复杂就可
以有多复杂，我们很快就没寄存器用了！

很幸运，有个简单的解决方案。和所有的现代处理器一样，x86-64 处理器有一
个栈，是个不错的存一些东西的地方。所以我们不把项从 rax 移动到 rdx 了，
而是把它压到栈顶。不熟悉 x86-64 汇编的人注意了，压栈操作写成

		pushq	操作数

退栈写成	popq	操作数

所以我们把 expression() 中的 emitLine() 调用改成这样：

		emitLine("pushq	%rax");

并在循环的结尾处加上

		emitLine("addq	$8,	%rsp");

add() 和 substract() 中的相应地改成

		emitLine("addq	(%rsp),	%rax");

和		emitLine("subq	(%rsp),	%rax");
现在再试试解析器，确保我们没把它搞炸了。

再说一遍，生成的代码又慢了一点，但是这么干是必须的，你马上就会明白这一
点。

乘法和除法

现在我们得做点严肃的事情了。你已经知道了，这个世界上除了加法和减法还有
别的运算....表达式里也可以出现乘法和除法。你也肯定知道加减乘除是有顺序
的，所以在这个表达式

		2 + 3 * 4
中，我们知道要先乘再加。（知道为什么要用栈了吧？）

早期的编译器技术通过一些超级复杂的东西来保证运算符优先级。但是，后来大
家发现，用不上这么麻烦....这些规则可以通过我们的自顶向下解析器轻松实现
。当然，到现在我们还是只把单个数字当作项。

更一般一点，我们可以把项定义为因式的积，换而言之

		<term> ::= <factor> [ <mulop> <factor> ]*

factor（因式）是什么？现在它....它就是一个数字。

注意这种相似性：项和表达式有相同的形式。事实上，我们可以略作复制粘贴就
把它加到我们的解析器中。但是为了避免迷惑性，下面是完整的解析函数。（注
意我们在 divide() 中调换操作数顺序的方式，以及将 rax 中值符号扩展到
rdx 的 cqoq 指令）

local function factor()
	emitLine("movq	$" .. getNum() .. ",	%rax");
end

local function multiply()
	match('*');
	factor();
	emitLine("imulq	(%rsp)");
end

local function divide()
	match('/');
	factor();
	emitLine("xchgq	(%rsp),	%rax");
	emitLine("cqto");
	emitLine("divq	(%rsp)");
end

local function term()
	factor();
	while look == '*' or look == '/'
	do
		emitLine("pushq	%rax");
		if look == '*'
		then
			multiply();
		elseif look == '/'
		then
			divide();
		else
			expect("mulop");
		end
		emitLine("addq	$8,	%rsp");
	end
end

local function add()
	match('+');
	term();
	emitLine("addq	(%rsp),	%rax");
end

local function substract()
	match('-');
	term();
	emitLine("subq	(%rsp),	%rax");
	emitLine("negq	%rax");
end

local function expression()
	term();

	while look == '+' or look == '-'
	do
		emitLine("pushq	%rax");
		if look == '+'
		then
			add();
		elseif look == '-'
		then
			substract();
		else
			expect("Addop");
		end
		emitLine("subq	$8,	%rsp");
	end
end

大功告成！一个几乎全功能的解析器只用了 150 行 Lua 代码！如果你不管性能
的话，输出看起来已经像是实用的样子了（我希望你会这么做）记住了，我们并
不是为了生成最好的目标代码。

括号

我们可以现在让这个解释器支持数学表达式中的括号。你应该知道，括号是用来
强制改变运算符优先级的机制。作为例子，下面的表达式

		2 * (3 + 4)

中的括号强制规定了要先算加法再算乘法。更重要的是括号允许我们写出任意复
杂的表达式，比如

		(1 + 2) / ((3 + 4) + (5 - 6))

让我们的解析器支持括号的关键在于意识到这一点：无论括号里面的表达式有多
复杂，在表达式括号外的部分看来它就像一个因子一样。所以因子的另一种形式
就是

		<factor> ::= (<expression>)

这里就产生了递归。一个表达式可以包含一个包含另一个表达式的因子，就这样
直到无穷无尽。

不管这样是不是麻烦了点，我们小心地往 factor() 里加几行代码试试。

local expression;

local function factor()
	if look == '('
	then
		match('(');
		expression();
		match(')');
	else
		emitLine("movq	$" .. getNum() .. ",	%rax");
	end
end

-- ...

-- 这里也改了！
expression = function()
	term();

	while look == '+' or look == '-'
	do
		emitLine("pushq	%rax");
		if look == '+'
		then
			add();
		elseif look == '-'
		then
			substract();
		else
			expect("Addop");
		end
		emitLine("addq	$8,	%rsp");
	end
end

再看看扩展解析器有多简单，以及代码和 BNF 的一致性。

老生常谈了，再把新版本的代码编译一下，确保它能解析合法的代码，并且会对
不合法的代码指出错误。

单目负号

现在我们有能处理任何表达式的解析器了，对吧....？那试试这个。

		-1

嘣！它爆炸了。expression() 希望表达式以整数开头，所以它对开头的负号很不
满意。然后你也能发现 +3 也会出错，类似

		-(3 - 2)

的东西也不行。

有几个修复这个问题的方法。最简单的（尽管不一定是最好的）方法是在这种表
达式的开头加上一个假想的 0，这样 -3 就变成 0 - 3 了。我们可以很轻松地
给现在的 expression() 打个补丁：

local function expression()
	if isAddop(look)
	then
		emitLine("xorq	%rax,	%rax");	-- 清零
	else
		term();
	end

	while isAddop(look)
	do
		emitLine("pushq	%rax");
		if look == '+'
		then
			add();
		elseif look == '-'
		then
			substract();
		else
			expect("Addop");
		end
		emitLine("addq	$8,	%rsp");
	end
end

我说过改点什么很容易了！这次我们只多写了六行新的 Lua 代码。注意新的函
数 isAddop()：对 addop 的检测出现了两次，所以我就把它写成了一个函数。
isAddop() 应该很容易写出来，类似这个样子：

-- 识别一个 Addop（加号或者减号）

local function isAddop(c)
	return c == '+' or c == '-;
end

好了，现在改一下代码然后重新运行一下。你也应该把 isAddop() 写到我们的
基础代码中，之后会用到。再试试输入 -1。嗯....输出的代码质量实在难以恭
维：仅仅加载一个常量就花了六行....但是至少是对的。记住了，我们并没想
要取代 GCC 的地位。

现在我们写完表达式解析器的基本结构了。这个版本的程序应该能正确地解析并
编译所有你想写出的表达式。虽然我们还是局限在处理单个的十进制数字，但是
我希望你们能明白只需要做一点小改动就能扩展我们的解析器。你现在再听到变
量和函数调用也相当于一个因子的时候，或许已经不会感到惊讶了。

下一节课程中，我会向你展示扩展我们的解析器允许其处理这些东西有多简单，
我也会展示一下处理包含多位的数字和变量名有多容易。你也能看到了，我们离
一个真正实用的解析器不远了。

关于优化的三言两语

在这节课的早些时候，我说过会给出一些提高生成的代码质量的建议。我说过了
，生成高效的代码不是这系列文章的主题。但是你至少需要知道我们没在浪费时
间....我们可以再修改一下我们的解析器让生成的代码好一些，而不用把我们已
经写的代码全部扔掉。看起来很合理，有一些优化做起来并不难....只是需要在
解析器里多写一点代码。

我们有两个可选择的方案：
  o 在生成代码之后补救一下

    这是窥孔优化的核心思想。总的想法是我们编译器会生成什么样的指令，我
    们也很容易找出其中低效的指令序列（比如上面加载 -1 的代码）。所以要
    做的事情就是扫描生成的代码，识别其中的此类指令序列，然后用好一些的
    代码代换它们。这是反向的宏展开，也很显然是一种模式匹配。唯一的复杂
    点是不良的指令序列太多了。窥孔优化就得名于这种优化只检查代码中的一
    小块，但却在不需要大幅改动编译器的结构的前提下极大提高了生成代码的
    质量。确实要付出一些代价，我们的编译器速度会下降，大小会变大，也会
    更复杂。查找这些指令序列需要很多 if 分支，每一个都增加了滋生 bug
    的机会。而且，很明显这很花时间。

    窥孔优化器的经典实现中，它会作为编译器的第二趟代码处理被运行。输出
    的代码被写入到磁盘中，然后优化器读取这些代码，处理之后再写回磁盘。
    事实上，有的实现中优化器和编译器根本不是一个程序。但是因为优化器只
    透过一个小“窗口”看指令序列（它也因此得名），更好的实现是缓冲几行输
    出的代码，然后在每次对 emitLine() 的调用后扫描代码。

  o 尝试直接生成更好的代码

    这个方案要求我们在生成代码前寻找特例。例如，我们应该识别出来零常量
    并生成使用异或的清零指令而不是把零加载到寄存器。甚至这种情况下我们
    可以什么都不做，比如当需要给一个数加 0 的时候。近一点的例子，如果
    我们选择在 factor() 而非 expression() 中处理单目负号，我们就可以把
    -1 作为普通的常量处理，而不需要从其对应的正值中生成它。这些都不难
    做到....只是在代码中加上了更多的条件判断，因此我不在我们的程序中这
    么做。我是这么看待这件事的：如果我们有了一个能用的编译器，能生成能
    运行的代码，我们总是能回去修改一下它来提高生成的代码的质量。这就是
    世界上那些程序发布 2.0 版本的理由。

有另一种优化值得一提，它能够在不太费事的前提下生成效率高得多的代码。这
是我的发明：我没在别的任何出版物中看见过这种建议，虽然我也没有证据证明
这是我首创的。

有一种避免大量使用栈的方式，就是好好利用 CPU 的寄存器。回想一下我们只
能做加法和减法的时候，那时候我们只用 rax 和 rdx 寄存器，根本没用到栈，
对吧？那时候一切也都正常，因为只有这两个操作的前提下，“栈”永远不会深于
两层。

好的，x86-64 处理器有 16 个通用寄存器，为什么不把它用作一个自行维护的
栈呢？关键是要意识到在处理输入的时候，解析器知道栈上有多少东西，所以它
能正确地维护它。我们可以自行定义一个“栈指针”来记录我们现在在栈的第几层
，并且索引对应的寄存器。举个例子，这样的话 factor() 就不会把数据加载到
rax 中，而会加载到“栈顶寄存器”的位置上。

我们要做的就是把 CPU 在内存中的栈用自己维护的寄存器组成的栈代替。大部
分表达式不会用超过 16 个寄存器，所以我们能生成很不错的代码。当然，我
们也得处理栈深度超过 16 的极端情况，但是这样也没有问题。我们就让栈溢出
到 CPU 维护的那个在内存中的栈里。栈深度超过 16 的情况下，生成的代码也
不会比我们现在生成的差，小于 16 的话则肯定要好得多。

为了写这篇文章，我把这个方案实现了一下，并且确保它就像我跟你讲的一样工
作良好。确实是这样的。实践中你不能把 16 个寄存器全用掉，至少还得留一个
用来交换除法操作数的顺序。我们也得为包含函数调用的表达式保留一个寄存器
，但是对于大部分表达式来说，生成代码的大小已经显著减少了。

因此，如你所见，生成更好的代码没有那么难，但是确实会让我们的翻译器更加
复杂....我们现在没有必要涉及到这种复杂性。因此，我强烈建议我们这篇教程
接下来的部分继续忽略性能问题。作为保险，我们也已经学了一些提高代码质量
却不用重写整个编译器的方式。

下一节课程中，我们会把函数调用和变量作为因子处理。你们会发现处理多字符
标识符和内嵌的空白字符有多容易。

			版权声明
Copyright (C) 1988 Jack W. Crenshaw. 保留一切权利。
本文由梓瑶翻译并重写为 Lua 代码
